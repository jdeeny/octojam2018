#####
# Tetra Interpreter
###

:macro TETRA_NEXT { jump tetra_decode }

# Tetra data is put on the same stack that is used in the rest of the program, but
# it employs a second stack, the Tetra Call Stack, to store call data for the
# interpreter. Currently, this stack is 256 bytes, but that may not be appropriate (too much?).
# TODO: Analyze stack usage

:alias TETRA_SP vD

:calc TETRA_CALLSTACK_SIZE { ( SEG_TETRA_CALLSTACK_END - SEG_TETRA_CALLSTACK_START ) + 1 }
:macro tetra_callstack_decr_sp bytes { stack_decr_sp TETRA_SP bytes }
:macro tetra_callstack_incr_sp bytes { stack_incr_sp TETRA_SP bytes }
: tetra_callstack_load_sp stack_load_sp TETRA_SP SEG_TETRA_CALLSTACK_START ;
:macro tetra_callstack_push firstreg lastreg bytes { stack_push TETRA_SP tetra_callstack_load_sp firstreg lastreg bytes }
:macro tetra_callstack_pop firstreg lastreg bytes { stack_pop TETRA_SP tetra_callstack_load_sp firstreg lastreg bytes }
: tetra-stack-init stack_init TETRA_SP ;


: tetra_init
  tetra-stack-init
  ;


# Given a memory location, initialize the interpreter and execute the tetra
# code located there.
# PASS0/PASS1 = location of byte code
: tetra_exec
  # Initialize callstack
  tetra-stack-init  # There is nothing on the stack because this is the first word executed
  # Set PASS0,1 to point at bytecode (already there right?)
  # Call decoder to process the bytecode
  tetra_decode


#####
# tetra_decode
###
# Decode a tetra word and advance to the next
# input: v0 = dictionary entry
###
: tetra_decode_table

: tetra_decode_table_native     # v1, v2 = address of function to call
  # push location of next word
  # jump v1v2
  # the function will jump to tetra_decode

: tetra_decode_table_tetra      # v1, v2 = address of tetra bytestream

  # push location of next word
  # set tetra decode pointer to v1v2
  jump tetra_decode # execute the new word

: tetra_decode_table_literal
  # push literal on stack
  # advance to next word (replace data on callstack)
  jump tetra_decode

# Offsets into the table, these are used in the dictionary defs (and jumping into the table)
:calc TETRA_DEF_NATIVE { tetra_decode_table_native - tetra_decode_table }
:calc TETRA_DEF_TETRA { tetra_decode_table_tetra - tetra_decode_table }
:calc TETRA_DEF_LITERAL { tetra_decode_table_literal - tetra_decode_table }

:calc TETRA_CALLFRAME_BYTES { 2 }  # How many bytes of the stack are used for each tetra call

: tetra_load_next
  :breakpoint !load_next!
  ;

: tetra_decode
  # load next word into v0
  tetra_load_next

  i := tetra_dictionary
  i += v0
  i += v0
  i += v0       # Index into table (v0 * 3)
  load v0 - v2  # Fetch definition. v0 = type, v1 = loc-hi, v2 = loc-lo

  # Switch on type of word using jumptable
  jump0 tetra_decode_table


: tetra_native_return
  tetra_callstack_decr_sp TETRA_CALLFRAME_BYTES   # Drop this stack frame
  jump tetra_decode

: test_func
  vF := vF
  :breakpoint in_native_func
  ;


: test_tetra_word 1 1 0 4

: tetra_dictionary      # Dictionary entries are 3 bytes each
: tetra_dict_test_func TETRA_DEF_NATIVE hilo test_func :byte hi :byte lo
: tetra_dict_test_literal TETRA_DEF_LITERAL 0xAA 0x55
: tetra_dict_test_tetra TETRA_DEF_TETRA hilo test_tetra_word :byte hi :byte lo
: tetra_return TETRA_DEF_NATIVE hilo tetra_native_return :byte hi :byte lo
