:macro set-i-reg reg-hi reg-lo {
	:calc tgt { HERE + 6 }
	i := tgt
	save reg-hi - reg-lo
	0xF0 0x00 0x00 0x00
}

:const TILE_HEIGHT 6

:const SPRITE_TOP_LEFT 0
:const SPRITE_TOP_RIGHT 18
:const SPRITE_MIDDLE_LEFT 36
:const SPRITE_MIDDLE_RIGHT 54
:const SPRITE_BOTTOM_LEFT 72
:const SPRITE_BOTTOM_RIGHT 90

:const SEG_FRAMEBUFFER_UPPER 0xE4
:const SEG_FRAMEBUFFER 0xE400
:const SEG_HEX_CONTENTS_UPPER 0xF0
:const SEG_HEX_CONTENTS 0xF000
:const HEX_CONTENTS_OFFSET 0x80

:const X_WRAP 19
:const NEG_X_WRAP 19
:const Y_WRAP 11
:const NEG_Y_WRAP 11

:macro HEX_DOWN_RIGHT hexx hexy {
	 hexx += 2
	 hexy += 2
}

:macro HEX_DOWN_LEFT hexx hexy {
	 hexy += 2
}

:alias tilex v1
:alias tiley v0
:alias hexx v1
:alias hexy v0
:alias spritesegment v2
:alias planeoffset v3

# composited tile v4 v5 v6 v7 v8 v9
# next input buffer/tmp va vb vc vd ve vf
#updates next tile in stack
: composite-tiles
	#pull index of next tile to update from stack
	i := long dirty-tiles load v0 - v0
	if v0 == 0 then return #no tiles to update
	v0 += -2 save v0
	i += v0 load tilex - tiley

	#prep pointer to framebuffer, since we're about to destroy our tile coords
	#ve := tilex*12
	vd <<= tilex
	vd <<= vd
	ve <<= vd
	ve += vd
	#rows are 256-byte aligned, though a row only uses 228 bytes.
	vd := SEG_FRAMEBUFFER_UPPER
	vd += tiley
	i := store-tile-target save vd - ve

	#turn tileindex into hex coordinates 
	i := long wrap-around-counters load vb - ve
	#sub wrap counters, determine on whether
	#wrap front has hit the present tile
	#if wrapfront < tile coordinate, the tile is wrapped 
	vb -= tilex if vf == 1 then tilex += X_WRAP
	vc -= tiley if vf == 1 then tiley += Y_WRAP
	#whole wrap counters, premultiplied
	tilex += vd
	tiley += ve
	#offset based on the skewed coordinate system
	tilex -= tiley
	tilex >>= tilex
	#now our humble tilex and tiley are hexx and hexy

	hexy += SEG_HEX_CONTENTS_UPPER

	#start by drawing plane 1
	planeoffset := 0
	: compo-go-again
	if vf == 0 begin #the tile is the right side of a hex
		hexx <<= hexx
		hexx <<= hexx
		#get ground tile
		set-i-reg hexy hexx
		load vd - ve
		set-i-reg vd ve
		#this is the right side, so we need to load the second
		#graphic for this hex
		vf := 12
		i += vf
		i += planeoffset
		load v4 - v9
		
		#start getting hex contents
		hexx += HEX_CONTENTS_OFFSET

		spritesegment := SPRITE_BOTTOM_RIGHT
		compo-add-sprite
		HEX_DOWN_RIGHT hexx hexy
		spritesegment := SPRITE_MIDDLE_LEFT
		compo-add-sprite
		HEX_DOWN_LEFT hexx hexy
		spritesegment := SPRITE_TOP_RIGHT
		compo-add-sprite
		vf := 0
	else #the tile is the left side of a hex
		hexx <<= hexx
		hexx <<= hexx

		#get ground tile
		set-i-reg hexy hexx
		load vd - ve
		set-i-reg vd ve
		i += planeoffset
		load v4 - v9

		#start getting hex contents
		hexx += HEX_CONTENTS_OFFSET

		spritesegment := SPRITE_BOTTOM_LEFT
		compo-add-sprite
		HEX_DOWN_LEFT hexx hexy
		spritesegment := SPRITE_MIDDLE_RIGHT
		compo-add-sprite
		HEX_DOWN_RIGHT hexx hexy
		spritesegment := SPRITE_TOP_LEFT
		compo-add-sprite
		vf := 1
	end
	#save the plane to the frame buffer
	#i := long store tile target
	0xF0 0x00 : store-tile-target 0x00 0x00
	i += planeoffset save v0
	#go again with plane 2				
	if planeoffset != 0 then return
	planeoffset := TILE_HEIGHT
	jump compo-go-again

: compo-add-sprite
	set-i-reg hexy hexx
	load vd - ve
	if vd == 0 then return #empty hex
	set-i-reg vd ve
	i += spritesegment

	#mask
	load va - vf
	v9 &= vf v8 &= ve
	v7 &= vd v6 &= vc
	v5 &= vb v4 &= va

	#image
	vf := TILE_HEIGHT i += vf
	i += planeoffset
	load va - vf
	v9 += vf v8 += ve
	v7 += vd v6 += vc
	v5 += vb v4 += va
;

:alias x v0
:alias y v1
:alias rowcount v2
:alias colcount v3
:alias tilewidth v4
:alias rowoffset v5

#copies frame buffer onto screen
: draw-tiles
	#load the iterator & tile width from memory rather than setting it directly
	#these two values are fixed, though. It's just a faster/smaller way to set them
	i := long screen-offset load x - rowoffset
	i := long frame-buffer
	: frame-loop
	loop
		sprite x y 6
		rowcount += 1
		i += tilewidth
		x += 7
		if x == 133 then x := 0
		if rowcount != 19 then jump frame-loop
			if colcount == 20 then return
			rowcount := 0
			colcount += 1
		 	y += 6
			if y == 66 then y := 0
		again
#end draw-tiles

:alias hexx v0
:alias hexy v1
#marks a hex to be redrawn
#TODO: detect whether hex is on screen
: dirty-hex

	#convert hex to tile space
	#unskew
	hexx <<= hexx
	hexx += hexy
	#wrap screen
	i := long mod19 i += hexy
	load hexy - hexy
	i := long mod11 i += hexx
	load hexx - hexx

	#update size of tile update stack
	i :=  long dirty-tiles
	load vf - vf
	vf += 12 save vf - vf
	vf += -11 i += vf

	#mark the 6 tiles that an object in this hex
	#could be drawn to
	save hexy
	hexy += -1 save hexy
	hexy += -1 save hexy
	hexx += 1 save hexy
	hexy += 1 save hexy
	hexy += 1 save hexy
;

:alias xwrapsub v0 
:alias ywrapsub v1
:alias xwrap v2
:alias ywrap v3 
:alias xoff v4
:alias yoff v5
: compo-scroll-right
	i := long wrap-around-counters
	load xwrapsub - yoff
	if xwrapsub == 0 begin
		xwrap += X_WRAP
		xoff := 126
		xwrapsub := X_WRAP
	else
		xoff += -7
		xwrap += -1
	end
	save xwrapsub - yoff
	#TODO mark scrolled tiles to be updated
;
