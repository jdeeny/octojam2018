# Glyphs: 0 - 0x7F
# 0x80 - 0xff = Word or special
# Specials: colors, random select, ?

# Spaced by 2 so it indexes into the jumptable
:const G_ESC_MASK 0xE0
:const G_ESC_COLOR0 0xE2
:const G_ESC_COLOR1 0xE4
:const G_ESC_COLOR2 0xE6
:const G_ESC_COLOR3 0xE8
:const G_ESC_SPACE 0xEA
:const G_ESC_WORD 0xEC
:const G_ESC_RANDOM 0xEE
:const G_ESC_SFX 0xF0
:const G_ESC_PORTRAIT 0xF2
:const G_ESC_SUB 0xF4
:const G_ESC_END 0xF6

: text_jumptable_call
  jump0 text_jumptable
: text_jumptable
  jump _text_glyph
  jump _text_color0
  jump _text_color1
  jump _text_color2
  jump _text_color3
  jump _text_space
  jump _text_subword
  jump _text_randomchoice
  jump _text_sfx
  jump _text_portrait
  jump _text_substitution
  jump _text_end


# v_text_state is to be loaded/saved all at once
:alias v_text_state_x v4          # Text output location
:alias v_text_state_y v5
:alias v_text_state_left v6       # left and right limits
:alias v_text_state_right v7
:alias v_text_state_skip v8       # how many lines to skip at the beginning (scrolling)
:alias v_text_state_lines v9      # how many lines to draw total
:macro text_set_loc x y { v_text_state_x := x v_text_state_y := y }
:macro text_set_wrap left right { v_text_state_left := left v_text_state_right := right }
:macro text_set_scroll skip lines { v_text_state_skip := skip v_text_state_lines := lines }
:macro text_state_save { i := long text_state save v_text_state_x - v_text_state_lines }
:macro text_state_load { i := long text_state load v_text_state_x - v_text_state_lines }

# Temporary
:alias v_text_advance v0  # number of bytes to advance in stream
# Loaded when loading the next glyph
:alias v_text_load_glyph v1
:alias v_text_load_hi v2
:alias v_text_load_lo v3
:macro text_load_glyph { load v_text_load_glyph - v_text_load_lo }

# This will be moved to fardata. Save v_text_state stuff
: text_state 0 0 0 0 0 0 0 0 0

: _text_glyph
  fetch_glyph
  draw_glyph v_text_x v_text_y
  jump text_next
: _text_color0
  # replace the draw func? inside of the draw func?
  ;
: _text_color1
  ;
: _text_color2
  ;
: _text_color3
  ;
: _text_space
  ;
: _text_subword
  v_text_advance += 2
  ;
: _text_randomchoice
  # load choices and pick one
  # adjust address VVV
  jump text_next
: _text_sfx
  # launch sfx
  v_text_advance += 2
  jump text_next
: _text_portrait
  i := long ui_current_portrait
  save v_text_load_hi - v_text_load_lo
  v_text_advance += 2
  jump text_next
: _text_substitution
  # push onto stack
  v_text_advance += 2
  jump text_next
: _text_end
  # pop stack
  jump text_next




: text_next
  v_text_advance := 1
  call text_jumptable
  # increase pointer by v_text_advance

# i := word
: text_draw_word
: text_draw_word_internal
  # load the word onto stack & reg
  text_load_glyph # load character
  jump text_jumptable
: text_draw_word_continue






: text_state 1
: text_wrap 0 0 0 # on/off; x1; x2
: text_scroll 0 0 # Scroll off = 0 / number of lines nonzero; current scroll

# v0 := new_color
: set_text_color
  i := text_state
  save v0 - v0
  ;

# Draw a single glyph
:alias text_color v8
:alias text_id v0
:alias text_glyph_width v0
:alias text_x v4
:alias text_y v5

:alias text_scroll_state v9
:alias text_wrap_state vA
:alias text_wrap_x1 vB
:alias text_wrap_x2 vC

fetch_glyph_impl text_id v3 v2

: text_draw_glyph
  :breakpoint glyphaddr
    fetch_glyph
    load v2 - v3 # load address of glyph
    :breakpoint glyphaddr
    reg_set_i_v23
    load v0 # load width

    plane 1

    if text_color == 1 then draw_glyph text_x text_y
    if text_color == 3 then draw_glyph text_x text_y
    plane 2
    if text_color == 2 then draw_glyph text_x text_y
    if text_color == 3 then draw_glyph text_x text_y
    text_x += text_glyph_width
    ;


# v23 = word address, v4 = x, v5 = y
: text_draw_word
  i := text_state
  load text_color - text_color
  i := text_wrap
  load text_wrap_state - text_wrap_x2
  i := text_scroll
  load text_scroll_state - text_scroll_state
# Draw an entire word
# v23 = word address, v4 = x, v5 = y
: text_draw_word_noreset
  push v2 v3 2 # save the current spot

: text_draw_word_internal
  reg_set_i_v23
  load v0
  load v0
  if v0 == G_ESC_END then jump text_draw_word_end
  if v0 == G_ESC_WORD then jump text_draw_word_word
  if text_scroll_state != 0 then jump text_draw_word_internal_skip_draw
  text_draw_glyph
  jump text_draw_word_internal_after_draw
  : text_draw_word_internal_skip_draw
  text_measure_glyph
  : text_draw_word_internal_after_draw

  pop v2 v3 2
  math_add_u16_u8imm v2 v3 1
  push v2 v3 2
  jump text_draw_word_internal
: text_draw_word_end
  pop v2 v3 2
  vF := vF
  ;

: text_draw_word_word
  load v2 - v3
  if text_wrap_state != 0 then text_draw_word_check_wrap
  text_draw_word_noreset
  pop v2 v3 2
  math_add_u16_u8imm v2 v3 3
  push v2 v3 2
  text_x += 3
  jump text_draw_word_internal
  ;

: text_draw_word_check_wrap
  push v2 v5 4
  text_measure_word

  v0 := v4
  pop v4 v5 2
  v0 =- text_wrap_x2
  v0 -= text_x

  if vF != 0 then jump text_draw_word_check_wrap_nowrap
  if text_scroll_state == 0 then text_y += 6  # don't advance y if we are skipping scrolled lines
  if text_scroll_state != 0 then text_scroll_state += -1
  text_x := text_wrap_x1
  : text_draw_word_check_wrap_nowrap
  pop v2 v3 2
  ;


:macro text_clear_wrap {
  i := text_wrap
  v0 := 0
  save v0 - v0
}

:macro text_set_wrap x1 x2 {
  i := text_wrap
  v0 := 1
  v1 := x1
  v2 := x2
  save v0 - v2
}

# Measure an entire word
# v23 = word address
: text_measure_word
  text_x := 0
: text_measure_word_nozero
  push v2 v3 2 # save the current spot

: text_measure_word_internal
  reg_set_i_v23
  load v0
  if v0 == G_ESC_END then jump text_measure_word_end
  if v0 == G_ESC_WORD then jump text_measure_word_word
  vF := vF
  text_measure_glyph
  vF := vF

  pop v2 v3 2
  math_add_u16_u8imm v2 v3 1
  push v2 v3 2
  jump text_measure_word_internal
: text_measure_word_end
  pop v2 v3 2
  v4 += -2
  ;

: text_measure_word_word
  load v2 - v3
  text_measure_word_nozero
  pop v2 v3 2
  math_add_u16_u8imm v2 v3 3
  push v2 v3 2
  text_x += 3
  jump text_measure_word_internal
  ;

: text_measure_glyph
  i := long glyph_data
  i += text_id
  i += text_id
  load v2 - v3 # load address of glyph
  reg_set_i_v23
  load v0 # load width
  text_x += text_glyph_width
  # v4 holds width
  ;


# v23 = word v4 = x1 v5 = y v6 = x2
: text_draw_word_centered
  push v2 v6 6
  text_measure_word
  v0 >>= v4
  pop v2 v6 6
  v6 >>= v6
  v4 >>= v4
  v4 += v6
  v4 -= v0
  text_draw_word
  ;

:macro text_draw_word_at w x y { i := long w load v2 - v3 v4 := x v5 := y text_draw_word }
:macro text_draw_word_centered_at w x1 x2 y { i := long w load v2 - v3 v4 := x1 v5 := y v6 := x2 text_draw_word_centered }
