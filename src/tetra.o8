#####
# Tetra Interpreter
###

:macro TETRA_NEXT { jump tetra_decode }

# Tetra data is put on the same stack that is used in the rest of the program, but
# it employs a second stack, the Tetra Call Stack, to store call data for the
# interpreter. Currently, this stack is 256 bytes, but that may not be appropriate (too much?).
# TODO: Analyze stack usage

:alias TETRA_SP vD

:calc TETRA_CALLSTACK_SIZE { ( SEG_TETRA_CALLSTACK_END - SEG_TETRA_CALLSTACK_START ) + 1 }
:macro tetra_callstack_decr_sp bytes { stack_decr_sp TETRA_SP bytes }
:macro tetra_callstack_incr_sp bytes { stack_incr_sp TETRA_SP bytes }
: tetra_callstack_load_sp stack_load_sp TETRA_SP SEG_TETRA_CALLSTACK_START ;
:macro tetra_callstack_push firstreg lastreg bytes { stack_push TETRA_SP tetra_callstack_load_sp firstreg lastreg bytes }
:macro tetra_callstack_pop firstreg lastreg bytes { stack_pop TETRA_SP tetra_callstack_load_sp firstreg lastreg bytes }
: tetra-stack-init stack_init TETRA_SP ;


: tetra_init
  tetra-stack-init
  ;


# Given a memory location, initialize the interpreter and execute the tetra
# code located there.
# PASS0/PASS1 = location of byte code
: tetra_exec
  # Initialize callstack
  tetra-stack-init  # There is nothing on the stack because this is the first word executed
  # Set PASS0,1 to point at bytecode (already there right?)
  # Call decoder to process the bytecode
  tetra_decode


#####
# tetra_decode
###
# Decode a tetra word and advance to the next
# input: v0 = dictionary entry
###
: tetra_decode_table

: tetra_decode_table_native     # v1, v2 = address of function to call
  # push location of next word
  # jump v1v2
  # the function will jump to tetra_decode

: tetra_decode_table_tetra      # v1, v2 = address of tetra bytestream

  # push location of next word
  # set tetra decode pointer to v1v2
  jump tetra_decode # execute the new word

: tetra_decode_table_literal
  # push literal on stack
  # advance to next word (replace data on callstack)
  jump tetra_decode

# Offsets into the table, these are used in the dictionary defs (and jumping into the table)
:calc TETRA_DEF_NATIVE { tetra_decode_table_native - tetra_decode_table }
:calc TETRA_DEF_TETRA { tetra_decode_table_tetra - tetra_decode_table }
:calc TETRA_DEF_LITERAL { tetra_decode_table_literal - tetra_decode_table }

:calc TETRA_CALLFRAME_BYTES { 2 }  # How many bytes of the stack are used for each tetra call

: tetra_load_next
  :breakpoint !load_next!
  ;

: tetra_decode
  # load next word into v0
  tetra_load_next

  i := tetra_dictionary
  i += v0
  i += v0
  i += v0       # Index into table (v0 * 3)
  load v0 - v2  # Fetch definition. v0 = type, v1 = loc-hi, v2 = loc-lo

  # Switch on type of word using jumptable
  jump0 tetra_decode_table


# This is a basic template
:macro impl_tetra_native_nop {
  : tetra_native_nop    # --
  # Do stuff here if not nop
  jump tetra_decode
}

:macro impl_tetra_native_return {
: tetra_native_return
  tetra_callstack_decr_sp TETRA_CALLFRAME_BYTES   # Drop this stack frame
  jump tetra_decode
}

:macro impl_tetra_native_add {
: tetra_native_add    # a, b -- a+b
  pop v0 v1 2
  v0 += v1
  push v0 v0 1
  jump tetra_decode
}

:macro impl_tetra_native_sub {
: tetra_native_sub    # a, b -- a-b
  pop v0 v1 2
  v0 -= v1
  push v0 v0 1
  jump tetra_decode
}
:macro impl_tetra_native_load {
: tetra_native_load # hi, lo -- *(hilo)
  pop v0 v1 2
  reg_set_i_v0v1
  load v0 v0
  push v0 v0 1
  jump tetra_decode
}
:macro impl_tetra_native_store {
: tetra_native_store  # x, hi, lo --    [*(hilo) := x]
  pop v0 v2 3
  reg_set_i_v0v1
  save v2 v2
  jump tetra_decode
}
